0a1,5
> (*
>    This #1 FI
> le presents a fairly large example #1 OF
>  Cool programm#1 IN
> g.  The
2,38c7,18
< TYPEID List
< INHERITS
< TYPEID IO
< '{'
< OBJECTID isNil
< '('
< ')'
< ':'
< TYPEID Bool
< '{'
< '{'
< OBJECTID abort
< '('
< ')'
< ';'
< BOOL_CONST true
< ';'
< '}'
< '}'
< ';'
< OBJECTID cons
< '('
< OBJECTID hd
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID Cons
< '{'
< '('
< LET
< OBJECTID new_cell
< ':'
< TYPEID Cons
< ASSIGN
< NEW
< TYPEID Cons
---
>  List de#1 FI
> nes the names #1 OF
>  standard list operations ala Scheme:
> car, cdr, cons, isNil, rev, sort, rcons (add an element to the end #1 OF
> 
> the list), and pr#1 IN
> t_list.  In the List #1 CLASS
>  most #1 OF
>  these functions
> are just stubs that abort #1 IF
>  ever called.  The #1 CLASS
> es Nil and Cons
40,537c20,230
< OBJECTID new_cell
< '.'
< OBJECTID init
< '('
< OBJECTID hd
< ','
< OBJECTID self
< ')'
< ')'
< '}'
< ';'
< OBJECTID car
< '('
< ')'
< ':'
< TYPEID Int
< '{'
< '{'
< OBJECTID abort
< '('
< ')'
< ';'
< NEW
< TYPEID Int
< ';'
< '}'
< '}'
< ';'
< OBJECTID cdr
< '('
< ')'
< ':'
< TYPEID List
< '{'
< '{'
< OBJECTID abort
< '('
< ')'
< ';'
< NEW
< TYPEID List
< ';'
< '}'
< '}'
< ';'
< OBJECTID rev
< '('
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID cdr
< '('
< ')'
< '}'
< ';'
< OBJECTID sort
< '('
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID cdr
< '('
< ')'
< '}'
< ';'
< OBJECTID insert
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID cdr
< '('
< ')'
< '}'
< ';'
< OBJECTID rcons
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID cdr
< '('
< ')'
< '}'
< ';'
< OBJECTID print_list
< '('
< ')'
< ':'
< TYPEID Object
< '{'
< OBJECTID abort
< '('
< ')'
< '}'
< ';'
< '}'
< ';'
< CLASS
< TYPEID Cons
< INHERITS
< TYPEID List
< '{'
< OBJECTID xcar
< ':'
< TYPEID Int
< ';'
< OBJECTID xcdr
< ':'
< TYPEID List
< ';'
< OBJECTID isNil
< '('
< ')'
< ':'
< TYPEID Bool
< '{'
< BOOL_CONST false
< '}'
< ';'
< OBJECTID init
< '('
< OBJECTID hd
< ':'
< TYPEID Int
< ','
< OBJECTID tl
< ':'
< TYPEID List
< ')'
< ':'
< TYPEID Cons
< '{'
< '{'
< OBJECTID xcar
< ASSIGN
< OBJECTID hd
< ';'
< OBJECTID xcdr
< ASSIGN
< OBJECTID tl
< ';'
< OBJECTID self
< ';'
< '}'
< '}'
< ';'
< OBJECTID car
< '('
< ')'
< ':'
< TYPEID Int
< '{'
< OBJECTID xcar
< '}'
< ';'
< OBJECTID cdr
< '('
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID xcdr
< '}'
< ';'
< OBJECTID rev
< '('
< ')'
< ':'
< TYPEID List
< '{'
< '('
< OBJECTID xcdr
< '.'
< OBJECTID rev
< '('
< ')'
< ')'
< '.'
< OBJECTID rcons
< '('
< OBJECTID xcar
< ')'
< '}'
< ';'
< OBJECTID sort
< '('
< ')'
< ':'
< TYPEID List
< '{'
< '('
< OBJECTID xcdr
< '.'
< OBJECTID sort
< '('
< ')'
< ')'
< '.'
< OBJECTID insert
< '('
< OBJECTID xcar
< ')'
< '}'
< ';'
< OBJECTID insert
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID List
< '{'
< IF
< OBJECTID i
< '<'
< OBJECTID xcar
< THEN
< '('
< NEW
< TYPEID Cons
< ')'
< '.'
< OBJECTID init
< '('
< OBJECTID i
< ','
< OBJECTID self
< ')'
< ELSE
< '('
< NEW
< TYPEID Cons
< ')'
< '.'
< OBJECTID init
< '('
< OBJECTID xcar
< ','
< OBJECTID xcdr
< '.'
< OBJECTID insert
< '('
< OBJECTID i
< ')'
< ')'
< FI
< '}'
< ';'
< OBJECTID rcons
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID List
< '{'
< '('
< NEW
< TYPEID Cons
< ')'
< '.'
< OBJECTID init
< '('
< OBJECTID xcar
< ','
< OBJECTID xcdr
< '.'
< OBJECTID rcons
< '('
< OBJECTID i
< ')'
< ')'
< '}'
< ';'
< OBJECTID print_list
< '('
< ')'
< ':'
< TYPEID Object
< '{'
< '{'
< OBJECTID out_int
< '('
< OBJECTID xcar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\n"
< ')'
< ';'
< OBJECTID xcdr
< '.'
< OBJECTID print_list
< '('
< ')'
< ';'
< '}'
< '}'
< ';'
< '}'
< ';'
< CLASS
< TYPEID Nil
< INHERITS
< TYPEID List
< '{'
< OBJECTID isNil
< '('
< ')'
< ':'
< TYPEID Bool
< '{'
< BOOL_CONST true
< '}'
< ';'
< OBJECTID rev
< '('
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID self
< '}'
< ';'
< OBJECTID sort
< '('
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID self
< '}'
< ';'
< OBJECTID insert
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID List
< '{'
< OBJECTID rcons
< '('
< OBJECTID i
< ')'
< '}'
< ';'
< OBJECTID rcons
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID List
< '{'
< '('
< NEW
< TYPEID Cons
< ')'
< '.'
< OBJECTID init
< '('
< OBJECTID i
< ','
< OBJECTID self
< ')'
< '}'
< ';'
< OBJECTID print_list
< '('
< ')'
< ':'
< TYPEID Object
< '{'
< BOOL_CONST true
< '}'
< ';'
< '}'
< ';'
< CLASS
< TYPEID Main
< INHERITS
< TYPEID IO
< '{'
< OBJECTID l
< ':'
< TYPEID List
< ';'
< OBJECTID iota
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID List
< '{'
< '{'
< OBJECTID l
< ASSIGN
< NEW
< TYPEID Nil
< ';'
< '('
< LET
< OBJECTID j
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 0
< IN
< WHILE
< OBJECTID j
< '<'
< OBJECTID i
< LOOP
< '{'
< OBJECTID l
< ASSIGN
< '('
< NEW
< TYPEID Cons
< ')'
< '.'
< OBJECTID init
< '('
< OBJECTID j
< ','
< OBJECTID l
< ')'
< ';'
< OBJECTID j
< ASSIGN
< OBJECTID j
< '+'
< INT_CONST 1
< ';'
< '}'
< POOL
< ')'
< ';'
< OBJECTID l
< ';'
< '}'
< '}'
< ';'
< OBJECTID main
< '('
< ')'
< ':'
< TYPEID Object
< '{'
< '{'
< OBJECTID out_string
< '('
< STR_CONST "How many numbers to sort?"
< ')'
< ';'
< OBJECTID iota
< '('
< OBJECTID in_int
< '('
< ')'
< ')'
< '.'
< OBJECTID rev
< '('
< ')'
< '.'
< OBJECTID sort
< '('
< ')'
< '.'
< OBJECTID print_list
< '('
< ')'
< ';'
< '}'
< '}'
< ';'
< '}'
< ';'
---
> herit from List and de#1 FI
> ne the same operations, but now as
> appropriate to the empty list (for the Nil #1 CLASS
> ) and for cons cells (for
> the Cons #1 CLASS
> ).
> 
> The Ma#1 IN
>  #1 CLASS
>  puts all #1 OF
>  this code through the follow#1 IN
> g silly 
> test exercise:
> 
>    1. prompt for a number N
>    2. generate a list #1 OF
>  numbers 0..N-1
>    3. reverse the list
>    4. sort the list
>    5. pr#1 IN
> t the sorted list
> 
> Because the sort used is a quadratic space #1 IN
> sertion sort, sort#1 IN
> g
> moderately large lists will cause spim to run out #1 OF
>  memory.
> *)
> 
> Class List #1 INHERITS
>  IO { 
>         (* S#1 IN
> ce abort() returns Object, we need someth#1 IN
> g #1 OF
> 
> 	   type Bool at the end #1 OF
>  the block to satisfy the typechecker. 
>            This code is unreachable, s#1 IN
> ce abort() halts the program. *)
> 	isNil() : Bool { { abort(); true; } };
> 
> 	cons(hd : Int) : Cons {
> 	  (#1 LET
>  #1 NEW
> _cell : Cons <- #1 NEW
>  Cons #1 IN
> 
> 		#1 NEW
> _cell.#1 IN
> it(hd,self)
> 	  )
> 	};
> 
> 	(* 
> 	   S#1 IN
> ce abort "returns" type Object, we have to add
> 	   an expression #1 OF
>  type Int here to satisfy the typechecker.
> 	   This code is, #1 OF
>  course, unreachable.
>         *)
> 	car() : Int { { abort(); #1 NEW
>  Int; } };
> 
> 	cdr() : List { { abort(); #1 NEW
>  List; } };
> 
> 	rev() : List { cdr() };
> 
> 	sort() : List { cdr() };
> 
> 	#1 IN
> sert(i : Int) : List { cdr() };
> 
> 	rcons(i : Int) : List { cdr() };
> 	
> 	pr#1 IN
> t_list() : Object { abort() };
> };
> 
> Class Cons #1 INHERITS
>  List {
> 	xcar : Int;  -- We keep the car #1 IN
>  cdr #1 IN
>  attributes.
> 	xcdr : List; -- Because methods and features must have d#1 IF
> ferent names,
> 		     -- we use xcar and xcdr for the attributes and reserve
> 		     -- cons and car for the features.
> 
> 	isNil() : Bool { false };
> 
> 	#1 IN
> it(hd : Int, tl : List) : Cons {
> 	  {
> 	    xcar <- hd;
> 	    xcdr <- tl;
> 	    self;
> 	  }
> 	};
> 	  
> 	car() : Int { xcar };
> 
> 	cdr() : List { xcdr };
> 
> 	rev() : List { (xcdr.rev()).rcons(xcar) };
> 
> 	sort() : List { (xcdr.sort()).#1 IN
> sert(xcar) };
> 
> 	#1 IN
> sert(i : Int) : List {
> 		#1 IF
>  i < xcar #1 THEN
> 
> 			(#1 NEW
>  Cons).#1 IN
> it(i,self)
> 		#1 ELSE
> 
> 			(#1 NEW
>  Cons).#1 IN
> it(xcar,xcdr.#1 IN
> sert(i))
> 		#1 FI
> 
> 	};
> 
> 	rcons(i : Int) : List { (#1 NEW
>  Cons).#1 IN
> it(xcar, xcdr.rcons(i)) };
> 
> 	pr#1 IN
> t_list() : Object {
> 		{
> 		     out_#1 IN
> t(xcar);
> 		     out_str#1 IN
> g("\n");
> 		     xcdr.pr#1 IN
> t_list();
> 		}
> 	};
> };
> 
> Class Nil #1 INHERITS
>  List {
> 	isNil() : Bool { true };
> 
>         rev() : List { self };
> 
> 	sort() : List { self };
> 
> 	#1 IN
> sert(i : Int) : List { rcons(i) };
> 
> 	rcons(i : Int) : List { (#1 NEW
>  Cons).#1 IN
> it(i,self) };
> 
> 	pr#1 IN
> t_list() : Object { true };
> 
> };
> 
> Class Ma#1 IN
>  #1 INHERITS
>  IO {
> 
> 	l : List;
> 
> 	(* iota maps its #1 IN
> teger argument n #1 IN
> to the list 0..n-1 *)
> 	iota(i : Int) : List {
> 	    {
> 		l <- #1 NEW
>  Nil;
> 		(#1 LET
>  j : Int <- 0 #1 IN
> 
> 		   #1 WHILE
>  j < i 
> 		   #1 LOOP
>  
> 		     {
> 		       l <- (#1 NEW
>  Cons).#1 IN
> it(j,l);
> 		       j <- j + 1;
> 		     } 
> 		   #1 POOL
> 
> 		);
> 		l;
> 	    }
> 	};		
> 
> 	ma#1 IN
> () : Object {
> 	   {
> 	     out_str#1 IN
> g("How many numbers to sort?");
> 	     iota(#1 IN
> _#1 IN
> t()).rev().sort().pr#1 IN
> t_list();
> 	   }
> 	};
> };			    
> 
