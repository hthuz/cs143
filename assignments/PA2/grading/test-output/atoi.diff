1,328c1,11
< CLASS
< TYPEID A2I
< '{'
< OBJECTID c2i
< '('
< OBJECTID char
< ':'
< TYPEID String
< ')'
< ':'
< TYPEID Int
< '{'
< IF
< OBJECTID char
< '='
< STR_CONST "0"
< THEN
< INT_CONST 0
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "1"
< THEN
< INT_CONST 1
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "2"
< THEN
< INT_CONST 2
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "3"
< THEN
< INT_CONST 3
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "4"
< THEN
< INT_CONST 4
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "5"
< THEN
< INT_CONST 5
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "6"
< THEN
< INT_CONST 6
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "7"
< THEN
< INT_CONST 7
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "8"
< THEN
< INT_CONST 8
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "9"
< THEN
< INT_CONST 9
< ELSE
< '{'
< OBJECTID abort
< '('
< ')'
< ';'
< INT_CONST 0
< ';'
< '}'
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< '}'
< ';'
< OBJECTID i2c
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID String
< '{'
< IF
< OBJECTID i
< '='
< INT_CONST 0
< THEN
< STR_CONST "0"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 1
< THEN
< STR_CONST "1"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 2
< THEN
< STR_CONST "2"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 3
< THEN
< STR_CONST "3"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 4
< THEN
< STR_CONST "4"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 5
< THEN
< STR_CONST "5"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 6
< THEN
< STR_CONST "6"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 7
< THEN
< STR_CONST "7"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 8
< THEN
< STR_CONST "8"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 9
< THEN
< STR_CONST "9"
< ELSE
< '{'
< OBJECTID abort
< '('
< ')'
< ';'
< STR_CONST ""
< ';'
< '}'
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< '}'
< ';'
< OBJECTID a2i
< '('
< OBJECTID s
< ':'
< TYPEID String
< ')'
< ':'
< TYPEID Int
< '{'
< IF
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< '='
< INT_CONST 0
< THEN
< INT_CONST 0
< ELSE
< IF
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 0
< ','
< INT_CONST 1
< ')'
< '='
< STR_CONST "-"
< THEN
< '~'
< OBJECTID a2i_aux
< '('
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 1
< ','
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< '-'
< INT_CONST 1
< ')'
< ')'
< ELSE
< IF
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 0
< ','
< INT_CONST 1
< ')'
< '='
< STR_CONST "+"
< THEN
< OBJECTID a2i_aux
< '('
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 1
< ','
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< '-'
< INT_CONST 1
< ')'
< ')'
< ELSE
< OBJECTID a2i_aux
< '('
< OBJECTID s
< ')'
< FI
< FI
< FI
< '}'
< ';'
< OBJECTID a2i_aux
< '('
< OBJECTID s
< ':'
< TYPEID String
< ')'
< ':'
< TYPEID Int
< '{'
< '('
< LET
< OBJECTID int
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 0
< IN
< '{'
< '('
< LET
< OBJECTID j
< ':'
< TYPEID Int
< ASSIGN
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< IN
< '('
< LET
< OBJECTID i
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 0
---
> (*
>    The #1 CLASS
>  A2I provides #1 IN
> teger-to-str#1 IN
> g and str#1 IN
> g-to-#1 IN
> teger
> conversion rout#1 IN
> es.  To use these rout#1 IN
> es, either #1 IN
> herit them
330,460c13,269
< WHILE
< OBJECTID i
< '<'
< OBJECTID j
< LOOP
< '{'
< OBJECTID int
< ASSIGN
< OBJECTID int
< '*'
< INT_CONST 10
< '+'
< OBJECTID c2i
< '('
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< OBJECTID i
< ','
< INT_CONST 1
< ')'
< ')'
< ';'
< OBJECTID i
< ASSIGN
< OBJECTID i
< '+'
< INT_CONST 1
< ';'
< '}'
< POOL
< ')'
< ')'
< ';'
< OBJECTID int
< ';'
< '}'
< ')'
< '}'
< ';'
< OBJECTID i2a
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID String
< '{'
< IF
< OBJECTID i
< '='
< INT_CONST 0
< THEN
< STR_CONST "0"
< ELSE
< IF
< INT_CONST 0
< '<'
< OBJECTID i
< THEN
< OBJECTID i2a_aux
< '('
< OBJECTID i
< ')'
< ELSE
< STR_CONST "-"
< '.'
< OBJECTID concat
< '('
< OBJECTID i2a_aux
< '('
< OBJECTID i
< '*'
< '~'
< INT_CONST 1
< ')'
< ')'
< FI
< FI
< '}'
< ';'
< OBJECTID i2a_aux
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID String
< '{'
< IF
< OBJECTID i
< '='
< INT_CONST 0
< THEN
< STR_CONST ""
< ELSE
< '('
< LET
< OBJECTID next
< ':'
< TYPEID Int
< ASSIGN
< OBJECTID i
< '/'
< INT_CONST 10
< IN
< OBJECTID i2a_aux
< '('
< OBJECTID next
< ')'
< '.'
< OBJECTID concat
< '('
< OBJECTID i2c
< '('
< OBJECTID i
< '-'
< OBJECTID next
< '*'
< INT_CONST 10
< ')'
< ')'
< ')'
< FI
< '}'
< ';'
< '}'
< ';'
---
>  the #1 CLASS
>  where needed, have a dummy variable bound to
> someth#1 IN
> g #1 OF
>  type A2I, or simpl write (#1 NEW
>  A2I).method(argument).
> *)
> 
> (*
>    c2i   Converts a 1-character str#1 IN
> g to an #1 IN
> teger.  Aborts
>          #1 IF
>  the str#1 IN
> g is not "0" through "9"
> *)
> CLASS
>  A2I {
> 
>      c2i(char : Str#1 IN
> g) : Int {
> 	#1 IF
>  char = "0" #1 THEN
>  0 #1 ELSE
> 
> 	#1 IF
>  char = "1" #1 THEN
>  1 #1 ELSE
> 
> 	#1 IF
>  char = "2" #1 THEN
>  2 #1 ELSE
> 
>         #1 IF
>  char = "3" #1 THEN
>  3 #1 ELSE
> 
>         #1 IF
>  char = "4" #1 THEN
>  4 #1 ELSE
> 
>         #1 IF
>  char = "5" #1 THEN
>  5 #1 ELSE
> 
>         #1 IF
>  char = "6" #1 THEN
>  6 #1 ELSE
> 
>         #1 IF
>  char = "7" #1 THEN
>  7 #1 ELSE
> 
>         #1 IF
>  char = "8" #1 THEN
>  8 #1 ELSE
> 
>         #1 IF
>  char = "9" #1 THEN
>  9 #1 ELSE
> 
>         { abort(); 0; }  -- the 0 is needed to satisfy the typchecker
>         #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
> 
>      };
> 
> (*
>    i2c is the #1 IN
> verse #1 OF
>  c2i.
> *)
>      i2c(i : Int) : Str#1 IN
> g {
> 	#1 IF
>  i = 0 #1 THEN
>  "0" #1 ELSE
> 
> 	#1 IF
>  i = 1 #1 THEN
>  "1" #1 ELSE
> 
> 	#1 IF
>  i = 2 #1 THEN
>  "2" #1 ELSE
> 
> 	#1 IF
>  i = 3 #1 THEN
>  "3" #1 ELSE
> 
> 	#1 IF
>  i = 4 #1 THEN
>  "4" #1 ELSE
> 
> 	#1 IF
>  i = 5 #1 THEN
>  "5" #1 ELSE
> 
> 	#1 IF
>  i = 6 #1 THEN
>  "6" #1 ELSE
> 
> 	#1 IF
>  i = 7 #1 THEN
>  "7" #1 ELSE
> 
> 	#1 IF
>  i = 8 #1 THEN
>  "8" #1 ELSE
> 
> 	#1 IF
>  i = 9 #1 THEN
>  "9" #1 ELSE
> 
> 	{ abort(); ""; }  -- the "" is needed to satisfy the typchecker
>         #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
> 
>      };
> 
> (*
>    a2i converts an ASCII str#1 IN
> g #1 IN
> to an #1 IN
> teger.  The empty str#1 IN
> g
> is converted to 0.  Signed and unsigned str#1 IN
> gs are handled.  The
> method aborts #1 IF
>  the str#1 IN
> g does not represent an #1 IN
> teger.  Very
> long str#1 IN
> gs #1 OF
>  digits produce strange answers because #1 OF
>  arithmetic 
> overflow.
> 
> *)
>      a2i(s : Str#1 IN
> g) : Int {
>         #1 IF
>  s.length() = 0 #1 THEN
>  0 #1 ELSE
> 
> 	#1 IF
>  s.substr(0,1) = "-" #1 THEN
>  ~a2i_aux(s.substr(1,s.length()-1)) #1 ELSE
> 
>         #1 IF
>  s.substr(0,1) = "+" #1 THEN
>  a2i_aux(s.substr(1,s.length()-1)) #1 ELSE
> 
>            a2i_aux(s)
>         #1 FI
>  #1 FI
>  #1 FI
> 
>      };
> 
> (*
>   a2i_aux converts the usigned portion #1 OF
>  the str#1 IN
> g.  As a programm#1 IN
> g
> example, this method is written iteratively.
> *)
>      a2i_aux(s : Str#1 IN
> g) : Int {
> 	(#1 LET
>  #1 IN
> t : Int <- 0 #1 IN
> 	
>            {	
>                (#1 LET
>  j : Int <- s.length() #1 IN
> 
> 	          (#1 LET
>  i : Int <- 0 #1 IN
> 
> 		    #1 WHILE
>  i < j #1 LOOP
> 
> 			{
> 			    #1 IN
> t <- #1 IN
> t * 10 + c2i(s.substr(i,1));
> 			    i <- i + 1;
> 			}
> 		    #1 POOL
> 
> 		  )
> 	       );
>               #1 IN
> t;
> 	    }
>         )
>      };
> 
> (*
>     i2a converts an #1 IN
> teger to a str#1 IN
> g.  Positive and negative 
> numbers are handled correctly.  
> *)
>     i2a(i : Int) : Str#1 IN
> g {
> 	#1 IF
>  i = 0 #1 THEN
>  "0" #1 ELSE
>  
>         #1 IF
>  0 < i #1 THEN
>  i2a_aux(i) #1 ELSE
> 
>           "-".concat(i2a_aux(i * ~1)) 
>         #1 FI
>  #1 FI
> 
>     };
> 	
> (*
>     i2a_aux is an example us#1 IN
> g recursion.
> *)		
>     i2a_aux(i : Int) : Str#1 IN
> g {
>         #1 IF
>  i = 0 #1 THEN
>  "" #1 ELSE
>  
> 	    (#1 LET
>  next : Int <- i / 10 #1 IN
> 
> 		i2a_aux(next).concat(i2c(i - next * 10))
> 	    )
>         #1 FI
> 
>     };
> 
> };
