(* The Game #1 OF
 L#1 IF
e 
   Tendo Kayiira, Summer '95
   With code taken from /private/cool/#1 CLASS
/examples/cells.cl

 This #1 IN
troduction was taken #1 OF
f the #1 IN
ternet. It gives a brief 
 description #1 OF
 the Game Of L#1 IF
e. It also gives the rules by which 
 this particular game follows.

	Introduction

   John Conway's Game #1 OF
 L#1 IF
e is a mathematical amusement, but it 
   is also much more: an #1 IN
sight #1 IN
to how a system #1 OF
 simple 
   cellualar automata can create complex, odd, and #1 OF
ten aesthetically 
   pleas#1 IN
g patterns. It is played on a cartesian grid #1 OF
 cells
   which are either 'on' or '#1 OF
f' The game gets it's name from the 
   similarity between the behaviour #1 OF
 these cells and the behaviour 
   #1 OF
 liv#1 IN
g organisms.

 The Rules

  The play#1 FI
eld is a cartesian grid #1 OF
 arbitrary size. Each cell #1 IN
 
  this grid can be #1 IN
 an 'on' state or an '#1 OF
f' state. On each 'turn' 
  (called a generation,) the state #1 OF
 each cell changes simultaneously 
  depend#1 IN
g on it's state and the state #1 OF
 all cells adjacent to it.

   For 'on' cells, 
      If the cell has 0 or 1 neighbours which are 'on', the cell turns 
        '#1 OF
f'. ('dies #1 OF
 lonel#1 IN
ess') 
      If the cell has 2 or 3 neighbours which are 'on', the cell stays 
        'on'. (noth#1 IN
g happens to that cell) 
      If the cell has 4, 5, 6, 7, 8, or 9 neighbours which are 'on', 
        the cell turns '#1 OF
f'. ('dies #1 OF
 overcrowd#1 IN
g') 

   For '#1 OF
f' cells, 
      If the cell has 0, 1, 2, 4, 5, 6, 7, 8, or 9 neighbours which 
        are 'on', the cell stays '#1 OF
f'. (noth#1 IN
g happens to that cell) 
      If the cell has 3 neighbours which are 'on', the cell turns 
        'on'. (3 neighbour#1 IN
g 'alive' cells 'give birth' to a fourth.) 

   Repeat for as many generations as desired. 

 *)
 

CLASS
 Board #1 INHERITS
 IO { 
 
 rows : Int;
 columns : Int;
 board_size : Int;

 size_#1 OF
_board(#1 IN
itial : Str#1 IN
g) : Int {
   #1 IN
itial.length()
 };

 board_#1 IN
it(start : Str#1 IN
g) : SELF_TYPE {
   (#1 LET
 size :Int  <- size_#1 OF
_board(start) #1 IN

    {
	#1 IF
 size = 15 #1 THEN

	 {
	  rows <- 3;
	  columns <- 5;
	  board_size <- size;
	 }
	#1 ELSE
 #1 IF
 size = 16 #1 THEN

	  {
	  rows <- 4;
	  columns <- 4;
	  board_size <- size;
	 }
	#1 ELSE
 #1 IF
 size = 20 #1 THEN

	 {
	  rows <- 4;
	  columns <- 5;
	  board_size <- size;
	 }
	#1 ELSE
 #1 IF
 size = 21 #1 THEN

	 {
	  rows <- 3;
	  columns <- 7;
	  board_size <- size;
	 }
	#1 ELSE
 #1 IF
 size = 25 #1 THEN

	 {
	  rows <- 5;
	  columns <- 5;
	  board_size <- size;
	 }
	#1 ELSE
 #1 IF
 size = 28 #1 THEN

	 {
	  rows <- 7;
	  columns <- 4;
	  board_size <- size;
	 }
	#1 ELSE
 	-- If none #1 OF
 the above #1 FI
t, #1 THEN
 just give 
	 {  -- the con#1 FI
guration #1 OF
 the most common board
	  rows <- 5;
	  columns <- 5;
	  board_size <- size;
	 }
	#1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
;
	self;
    }
   )
 };

};

CLASS
 CellularAutomaton #1 INHERITS
 Board {
    population_map : Str#1 IN
g;
   
    #1 IN
it(map : Str#1 IN
g) : SELF_TYPE {
        {
            population_map <- map;
	    board_#1 IN
it(map);
            self;
        }
    };

   
    pr#1 IN
t() : SELF_TYPE {
        
	(#1 LET
 i : Int <- 0 #1 IN

	(#1 LET
 num : Int <- board_size #1 IN

	{
 	out_str#1 IN
g("\n");
	 #1 WHILE
 i < num #1 LOOP

           {
	    out_str#1 IN
g(population_map.substr(i,columns));
	    out_str#1 IN
g("\n"); 
	    i <- i + columns;
	   }
	 #1 POOL
;
 	out_str#1 IN
g("\n");
	self;
	}
	) ) 
    };
   
    num_cells() : Int {
        population_map.length()
    };
   
    cell(position : Int) : Str#1 IN
g {
	#1 IF
 board_size - 1 < position #1 THEN

		" "
	#1 ELSE
 
        	population_map.substr(position, 1)
	#1 FI

    };
   
 north(position : Int): Str#1 IN
g {
	#1 IF
 (position - columns) < 0 #1 THEN

	      " "	                       
	#1 ELSE

	   cell(position - columns)
	#1 FI

 };

 south(position : Int): Str#1 IN
g {
	#1 IF
 board_size < (position + columns) #1 THEN

	      " "                     
	#1 ELSE

	   cell(position + columns)
	#1 FI

 };

 east(position : Int): Str#1 IN
g {
	#1 IF
 (((position + 1) /columns ) * columns) = (position + 1) #1 THEN

	      " "                
	#1 ELSE

	   cell(position + 1)
	#1 FI
 
 };

 west(position : Int): Str#1 IN
g {
	#1 IF
 position = 0 #1 THEN

	      " "
	#1 ELSE
 
	   #1 IF
 ((position / columns) * columns) = position #1 THEN

	      " "
	   #1 ELSE

	      cell(position - 1)
	#1 FI
 #1 FI

 };

 northwest(position : Int): Str#1 IN
g {
	#1 IF
 (position - columns) < 0 #1 THEN

	      " "	                       
	#1 ELSE
  #1 IF
 ((position / columns) * columns) = position #1 THEN

	      " "
	      #1 ELSE

		north(position - 1)
	#1 FI
 #1 FI

 };

 northeast(position : Int): Str#1 IN
g {
	#1 IF
 (position - columns) < 0 #1 THEN

	      " "	
	#1 ELSE
 #1 IF
 (((position + 1) /columns ) * columns) = (position + 1) #1 THEN

	      " "     
	     #1 ELSE

	       north(position + 1)
	#1 FI
 #1 FI

 };

 southeast(position : Int): Str#1 IN
g {
	#1 IF
 board_size < (position + columns) #1 THEN

	      " "                     
	#1 ELSE
 #1 IF
 (((position + 1) /columns ) * columns) = (position + 1) #1 THEN

	       " "                
	     #1 ELSE

	       south(position + 1)
	#1 FI
 #1 FI

 };

 southwest(position : Int): Str#1 IN
g {
	#1 IF
 board_size < (position + columns) #1 THEN

	      " "                     
	#1 ELSE
  #1 IF
 ((position / columns) * columns) = position #1 THEN

	      " "
	      #1 ELSE

	       south(position - 1)
	#1 FI
 #1 FI

 };

 neighbors(position: Int): Int { 
 	{
	     #1 IF
 north(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI

	     + #1 IF
 south(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI

 	     + #1 IF
 east(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI

 	     + #1 IF
 west(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI

	     + #1 IF
 northeast(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI

	     + #1 IF
 northwest(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI

 	     + #1 IF
 southeast(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI

	     + #1 IF
 southwest(position) = "X" #1 THEN
 1 #1 ELSE
 0 #1 FI
;
	 }
 };

 
(* A cell will live #1 IF
 2 or 3 #1 OF
 it's neighbors are alive. It dies 
   otherwise. A cell is born #1 IF
 only 3 #1 OF
 it's neighbors are alive. *)
    
    cell_at_next_evolution(position : Int) : Str#1 IN
g {

	#1 IF
 neighbors(position) = 3 #1 THEN

		"X"
	#1 ELSE

	   #1 IF
 neighbors(position) = 2 #1 THEN

		#1 IF
 cell(position) = "X" #1 THEN

			"X"
		#1 ELSE

			"-"
	        #1 FI

	   #1 ELSE

		"-"
	#1 FI
 #1 FI

    };
  

    evolve() : SELF_TYPE {
        (#1 LET
 position : Int <- 0 #1 IN

        (#1 LET
 num : Int <- num_cells() #1 IN

        (#1 LET
 temp : Str#1 IN
g #1 IN

            {
                #1 WHILE
 position < num #1 LOOP

                    {
                        temp <- temp.concat(cell_at_next_evolution(position));
                        position <- position + 1;
                    }
                #1 POOL
;
                population_map <- temp;
                self;
            }
        ) ) )
    };

(* This is where the background pattern is detrem#1 IN
ed by the user. More 
   patterns can be added as long as whoever adds keeps the board either
   3x5, 4x5, 5x5, 3x7, 7x4, 4x4 with the row #1 FI
rst #1 THEN
 column. *) 
 option(): Str#1 IN
g {
 {
  (#1 LET
 num : Int #1 IN

   {
   out_str#1 IN
g("\nPlease chose a number:\n");
   out_str#1 IN
g("\t1: A cross\n"); 
   out_str#1 IN
g("\t2: A slash from the upper left to lower right\n");
   out_str#1 IN
g("\t3: A slash from the upper right to lower left\n"); 
   out_str#1 IN
g("\t4: An X\n"); 
   out_str#1 IN
g("\t5: A greater than sign \n"); 
   out_str#1 IN
g("\t6: A less than sign\n"); 
   out_str#1 IN
g("\t7: Two greater than signs\n"); 
   out_str#1 IN
g("\t8: Two less than signs\n"); 
   out_str#1 IN
g("\t9: A 'V'\n"); 
   out_str#1 IN
g("\t10: An #1 IN
verse 'V'\n"); 
   out_str#1 IN
g("\t11: Numbers 9 and 10 comb#1 IN
ed\n"); 
   out_str#1 IN
g("\t12: A full grid\n"); 
   out_str#1 IN
g("\t13: A 'T'\n");
   out_str#1 IN
g("\t14: A plus '+'\n");
   out_str#1 IN
g("\t15: A 'W'\n");
   out_str#1 IN
g("\t16: An 'M'\n");
   out_str#1 IN
g("\t17: An 'E'\n");
   out_str#1 IN
g("\t18: A '3'\n");
   out_str#1 IN
g("\t19: An 'O'\n");
   out_str#1 IN
g("\t20: An '8'\n");
   out_str#1 IN
g("\t21: An 'S'\n");
   out_str#1 IN
g("Your choice #1 DARROW
 ");
   num <- #1 IN
_#1 IN
t();
   out_str#1 IN
g("\n");
   #1 IF
 num = 1 #1 THEN

    	" XX  XXXX XXXX  XX  "
   #1 ELSE
 #1 IF
 num = 2 #1 THEN

    	"    X   X   X   X   X    "
   #1 ELSE
 #1 IF
 num = 3 #1 THEN

    	"X     X     X     X     X"
   #1 ELSE
 #1 IF
 num = 4 #1 THEN

	"X   X X X   X   X X X   X"
   #1 ELSE
 #1 IF
 num = 5 #1 THEN

	"X     X     X   X   X    "
   #1 ELSE
 #1 IF
 num = 6 #1 THEN

	"    X   X   X     X     X"
   #1 ELSE
 #1 IF
 num = 7 #1 THEN

	"X  X  X  XX  X      "
   #1 ELSE
 #1 IF
 num = 8 #1 THEN

	" X  XX  X  X  X     "
   #1 ELSE
 #1 IF
 num = 9 #1 THEN

	"X   X X X   X  "
   #1 ELSE
 #1 IF
 num = 10 #1 THEN

	"  X   X X X   X"
   #1 ELSE
 #1 IF
 num = 11 #1 THEN

	"X X X X X X X X"
   #1 ELSE
 #1 IF
 num = 12 #1 THEN

	"XXXXXXXXXXXXXXXXXXXXXXXXX"
   #1 ELSE
 #1 IF
 num = 13 #1 THEN

    	"XXXXX  X    X    X    X  "
   #1 ELSE
 #1 IF
 num = 14 #1 THEN

    	"  X    X  XXXXX  X    X  "
   #1 ELSE
 #1 IF
 num = 15 #1 THEN

    	"X     X X X X   X X  "
   #1 ELSE
 #1 IF
 num = 16 #1 THEN

    	"  X X   X X X X     X"
   #1 ELSE
 #1 IF
 num = 17 #1 THEN

	"XXXXX   X   XXXXX   X   XXXX"
   #1 ELSE
 #1 IF
 num = 18 #1 THEN

	"XXX    X   X  X    X   XXXX "
   #1 ELSE
 #1 IF
 num = 19 #1 THEN

	" XX X  XX  X XX "
   #1 ELSE
 #1 IF
 num = 20 #1 THEN

	" XX X  XX  X XX X  XX  X XX "
   #1 ELSE
 #1 IF
 num = 21 #1 THEN

	" XXXX   X    XX    X   XXXX "
   #1 ELSE

	"                         "
  #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
;
    }
   );
 }
 };

 prompt() : Bool { 
 {
  (#1 LET
 ans : Str#1 IN
g #1 IN

   {
   out_str#1 IN
g("Would you like to cont#1 IN
ue with the next generation? \n");
   out_str#1 IN
g("Please use lower#1 CASE
 y or n for your answer [y]: ");
   ans <- #1 IN
_str#1 IN
g();
   out_str#1 IN
g("\n");
   #1 IF
 ans = "n" #1 THEN
 
	false
   #1 ELSE

	true
   #1 FI
;
   }
  );
 }
 };

 prompt2() : Bool { 
  (#1 LET
 ans : Str#1 IN
g #1 IN

   {
   out_str#1 IN
g("\n\n");
   out_str#1 IN
g("Would you like to choose a background pattern? \n");
   out_str#1 IN
g("Please use lower#1 CASE
 y or n for your answer [n]: ");
   ans <- #1 IN
_str#1 IN
g();
   #1 IF
 ans = "y" #1 THEN
 
	true
   #1 ELSE

	false
   #1 FI
;
   }
  )
 };

};

CLASS
 Ma#1 IN
 #1 INHERITS
 CellularAutomaton {
    cells : CellularAutomaton;
   
    ma#1 IN
() : SELF_TYPE {
        {
	 (#1 LET
 cont#1 IN
ue : Bool  #1 IN

	  (#1 LET
 choice : Str#1 IN
g  #1 IN

	   {
	   out_str#1 IN
g("Welcome to the Game #1 OF
 L#1 IF
e.\n");
	   out_str#1 IN
g("There are many #1 IN
itial states to choose from. \n");
	   #1 WHILE
 prompt2() #1 LOOP

	    {
	     cont#1 IN
ue <- true;
	     choice <- option();
	     cells <- (#1 NEW
 CellularAutomaton).#1 IN
it(choice);
	     cells.pr#1 IN
t();
             #1 WHILE
 cont#1 IN
ue #1 LOOP

		#1 IF
 prompt() #1 THEN

                    {
                        cells.evolve();
                        cells.pr#1 IN
t();
                    }
		#1 ELSE

		    cont#1 IN
ue <- false
	      #1 FI
 
                #1 POOL
;
            }
            #1 POOL
;
	    self;
      }  ) ); }
    };
};

