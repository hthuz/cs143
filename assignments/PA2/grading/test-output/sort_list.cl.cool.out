(*
   This #1 FI
le presents a fairly large example #1 OF
 Cool programm#1 IN
g.  The
CLASS
 List de#1 FI
nes the names #1 OF
 standard list operations ala Scheme:
car, cdr, cons, isNil, rev, sort, rcons (add an element to the end #1 OF

the list), and pr#1 IN
t_list.  In the List #1 CLASS
 most #1 OF
 these functions
are just stubs that abort #1 IF
 ever called.  The #1 CLASS
es Nil and Cons
IN
herit from List and de#1 FI
ne the same operations, but now as
appropriate to the empty list (for the Nil #1 CLASS
) and for cons cells (for
the Cons #1 CLASS
).

The Ma#1 IN
 #1 CLASS
 puts all #1 OF
 this code through the follow#1 IN
g silly 
test exercise:

   1. prompt for a number N
   2. generate a list #1 OF
 numbers 0..N-1
   3. reverse the list
   4. sort the list
   5. pr#1 IN
t the sorted list

Because the sort used is a quadratic space #1 IN
sertion sort, sort#1 IN
g
moderately large lists will cause spim to run out #1 OF
 memory.
*)

Class List #1 INHERITS
 IO { 
        (* S#1 IN
ce abort() returns Object, we need someth#1 IN
g #1 OF

	   type Bool at the end #1 OF
 the block to satisfy the typechecker. 
           This code is unreachable, s#1 IN
ce abort() halts the program. *)
	isNil() : Bool { { abort(); true; } };

	cons(hd : Int) : Cons {
	  (#1 LET
 #1 NEW
_cell : Cons <- #1 NEW
 Cons #1 IN

		#1 NEW
_cell.#1 IN
it(hd,self)
	  )
	};

	(* 
	   S#1 IN
ce abort "returns" type Object, we have to add
	   an expression #1 OF
 type Int here to satisfy the typechecker.
	   This code is, #1 OF
 course, unreachable.
        *)
	car() : Int { { abort(); #1 NEW
 Int; } };

	cdr() : List { { abort(); #1 NEW
 List; } };

	rev() : List { cdr() };

	sort() : List { cdr() };

	#1 IN
sert(i : Int) : List { cdr() };

	rcons(i : Int) : List { cdr() };
	
	pr#1 IN
t_list() : Object { abort() };
};

Class Cons #1 INHERITS
 List {
	xcar : Int;  -- We keep the car #1 IN
 cdr #1 IN
 attributes.
	xcdr : List; -- Because methods and features must have d#1 IF
ferent names,
		     -- we use xcar and xcdr for the attributes and reserve
		     -- cons and car for the features.

	isNil() : Bool { false };

	#1 IN
it(hd : Int, tl : List) : Cons {
	  {
	    xcar <- hd;
	    xcdr <- tl;
	    self;
	  }
	};
	  
	car() : Int { xcar };

	cdr() : List { xcdr };

	rev() : List { (xcdr.rev()).rcons(xcar) };

	sort() : List { (xcdr.sort()).#1 IN
sert(xcar) };

	#1 IN
sert(i : Int) : List {
		#1 IF
 i < xcar #1 THEN

			(#1 NEW
 Cons).#1 IN
it(i,self)
		#1 ELSE

			(#1 NEW
 Cons).#1 IN
it(xcar,xcdr.#1 IN
sert(i))
		#1 FI

	};

	rcons(i : Int) : List { (#1 NEW
 Cons).#1 IN
it(xcar, xcdr.rcons(i)) };

	pr#1 IN
t_list() : Object {
		{
		     out_#1 IN
t(xcar);
		     out_str#1 IN
g("\n");
		     xcdr.pr#1 IN
t_list();
		}
	};
};

Class Nil #1 INHERITS
 List {
	isNil() : Bool { true };

        rev() : List { self };

	sort() : List { self };

	#1 IN
sert(i : Int) : List { rcons(i) };

	rcons(i : Int) : List { (#1 NEW
 Cons).#1 IN
it(i,self) };

	pr#1 IN
t_list() : Object { true };

};

Class Ma#1 IN
 #1 INHERITS
 IO {

	l : List;

	(* iota maps its #1 IN
teger argument n #1 IN
to the list 0..n-1 *)
	iota(i : Int) : List {
	    {
		l <- #1 NEW
 Nil;
		(#1 LET
 j : Int <- 0 #1 IN

		   #1 WHILE
 j < i 
		   #1 LOOP
 
		     {
		       l <- (#1 NEW
 Cons).#1 IN
it(j,l);
		       j <- j + 1;
		     } 
		   #1 POOL

		);
		l;
	    }
	};		

	ma#1 IN
() : Object {
	   {
	     out_str#1 IN
g("How many numbers to sort?");
	     iota(#1 IN
_#1 IN
t()).rev().sort().pr#1 IN
t_list();
	   }
	};
};			    

