0a1,7
> (*
>  *  A contribution from Anne Sheets (sheets@cory)
>  *
>  *  Tests the arithmetic operations and various other th#1 IN
> gs
>  *)
> 
2,260c9,104
< TYPEID A
< '{'
< OBJECTID var
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 0
< ';'
< OBJECTID value
< '('
< ')'
< ':'
< TYPEID Int
< '{'
< OBJECTID var
< '}'
< ';'
< OBJECTID set_var
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID SELF_TYPE
< '{'
< '{'
< OBJECTID var
< ASSIGN
< OBJECTID num
< ';'
< OBJECTID self
< ';'
< '}'
< '}'
< ';'
< OBJECTID method1
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID SELF_TYPE
< '{'
< OBJECTID self
< '}'
< ';'
< OBJECTID method2
< '('
< OBJECTID num1
< ':'
< TYPEID Int
< ','
< OBJECTID num2
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID B
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< OBJECTID num1
< '+'
< OBJECTID num2
< ';'
< '('
< NEW
< TYPEID B
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< OBJECTID method3
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID C
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< '~'
< OBJECTID num
< ';'
< '('
< NEW
< TYPEID C
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< OBJECTID method4
< '('
< OBJECTID num1
< ':'
< TYPEID Int
< ','
< OBJECTID num2
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID D
< '{'
< IF
< OBJECTID num2
< '<'
< OBJECTID num1
< THEN
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< OBJECTID num1
< '-'
< OBJECTID num2
< ';'
< '('
< NEW
< TYPEID D
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< ELSE
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< OBJECTID num2
< '-'
< OBJECTID num1
< ';'
< '('
< NEW
< TYPEID D
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< FI
< '}'
< ';'
< OBJECTID method5
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID E
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 1
< IN
< '{'
< '('
< LET
< OBJECTID y
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 1
< IN
< WHILE
< OBJECTID y
< LE
< OBJECTID num
< LOOP
< '{'
< OBJECTID x
< ASSIGN
< OBJECTID x
< '*'
< OBJECTID y
< ';'
< OBJECTID y
< ASSIGN
< OBJECTID y
< '+'
< INT_CONST 1
< ';'
< '}'
< POOL
< ')'
< ';'
< '('
< NEW
< TYPEID E
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< '}'
< ';'
---
>  A {
> 
>    var : Int <- 0;
> 
>    value() : Int { var };
> 
>    set_var(num : Int) : SELF_TYPE {
>       {
>          var <- num;
>          self;
>       }
>    };
> 
>    method1(num : Int) : SELF_TYPE {  -- same
>       self
>    };
> 
>    method2(num1 : Int, num2 : Int) : B {  -- plus
>       (#1 LET
>  x : Int #1 IN
> 
> 	 {
>             x <- num1 + num2;
> 	    (#1 NEW
>  B).set_var(x);
> 	 }
>       )
>    };
> 
>    method3(num : Int) : C {  -- negate
>       (#1 LET
>  x : Int #1 IN
> 
> 	 {
>             x <- ~num;
> 	    (#1 NEW
>  C).set_var(x);
> 	 }
>       )
>    };
> 
>    method4(num1 : Int, num2 : Int) : D {  -- d#1 IF
> f
>             #1 IF
>  num2 < num1 #1 THEN
> 
>                (#1 LET
>  x : Int #1 IN
> 
> 		  {
>                      x <- num1 - num2;
> 	             (#1 NEW
>  D).set_var(x);
> 	          }
>                )
>             #1 ELSE
> 
>                (#1 LET
>  x : Int #1 IN
> 
> 		  {
> 	             x <- num2 - num1;
> 	             (#1 NEW
>  D).set_var(x);
> 		  }
>                )
>             #1 FI
> 
>    };
> 
>    method5(num : Int) : E {  -- factorial
>       (#1 LET
>  x : Int <- 1 #1 IN
> 
> 	 {
> 	    (#1 LET
>  y : Int <- 1 #1 IN
> 
> 	       #1 WHILE
>  y <= num #1 LOOP
> 
> 	          {
>                      x <- x * y;
> 	             y <- y + 1;
> 	          }
> 	       #1 POOL
> 
> 	    );
> 	    (#1 NEW
>  E).set_var(x);
> 	 }
>       )
>    };
> 
> };
> 
262,303c106,122
< TYPEID B
< INHERITS
< TYPEID A
< '{'
< OBJECTID method5
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID E
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< OBJECTID num
< '*'
< OBJECTID num
< ';'
< '('
< NEW
< TYPEID E
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< '}'
< ';'
---
>  B #1 INHERITS
>  A {  -- B is a number squared
> 
>    method5(num : Int) : E { -- square
>       (#1 LET
>  x : Int #1 IN
> 
> 	 {
>             x <- num * num;
> 	    (#1 NEW
>  E).set_var(x);
> 	 }
>       )
>    };
> 
> };
> 
305,383c124,152
< TYPEID C
< INHERITS
< TYPEID B
< '{'
< OBJECTID method6
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID A
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< '~'
< OBJECTID num
< ';'
< '('
< NEW
< TYPEID A
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< OBJECTID method5
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID E
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< OBJECTID num
< '*'
< OBJECTID num
< '*'
< OBJECTID num
< ';'
< '('
< NEW
< TYPEID E
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< '}'
< ';'
---
>  C #1 INHERITS
>  B {
> 
>    method6(num : Int) : A { -- negate
>       (#1 LET
>  x : Int #1 IN
> 
>          {
>             x <- ~num;
> 	    (#1 NEW
>  A).set_var(x);
>          }
>       )
>    };
> 
>    method5(num : Int) : E {  -- cube
>       (#1 LET
>  x : Int #1 IN
> 
> 	 {
>             x <- num * num * num;
> 	    (#1 NEW
>  E).set_var(x);
> 	 }
>       )
>    };
> 
> };
> 
385,452c154,187
< TYPEID D
< INHERITS
< TYPEID B
< '{'
< OBJECTID method7
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID Bool
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< ASSIGN
< OBJECTID num
< IN
< IF
< OBJECTID x
< '<'
< INT_CONST 0
< THEN
< OBJECTID method7
< '('
< '~'
< OBJECTID x
< ')'
< ELSE
< IF
< INT_CONST 0
< '='
< OBJECTID x
< THEN
< BOOL_CONST true
< ELSE
< IF
< INT_CONST 1
< '='
< OBJECTID x
< THEN
< BOOL_CONST false
< ELSE
< IF
< INT_CONST 2
< '='
< OBJECTID x
< THEN
< BOOL_CONST false
< ELSE
< OBJECTID method7
< '('
< OBJECTID x
< '-'
< INT_CONST 3
< ')'
< FI
< FI
< FI
< FI
< ')'
< '}'
< ';'
< '}'
< ';'
---
>  D #1 INHERITS
>  B {  
> 		
>    method7(num : Int) : Bool {  -- divisible by 3
>       (#1 LET
>  x : Int <- num #1 IN
> 
>             #1 IF
>  x < 0 #1 THEN
>  method7(~x) #1 ELSE
> 
>             #1 IF
>  0 = x #1 THEN
>  true #1 ELSE
> 
>             #1 IF
>  1 = x #1 THEN
>  false #1 ELSE
> 
> 	    #1 IF
>  2 = x #1 THEN
>  false #1 ELSE
> 
> 	       method7(x - 3)
> 	    #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
> 
>       )
>    };
> 
> };
> 
454,495c189,237
< TYPEID E
< INHERITS
< TYPEID D
< '{'
< OBJECTID method6
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID A
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< IN
< '{'
< OBJECTID x
< ASSIGN
< OBJECTID num
< '/'
< INT_CONST 8
< ';'
< '('
< NEW
< TYPEID A
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID x
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< '}'
< ';'
---
>  E #1 INHERITS
>  D {
> 
>    method6(num : Int) : A {  -- division
>       (#1 LET
>  x : Int #1 IN
> 
>          {
>             x <- num / 8;
> 	    (#1 NEW
>  A).set_var(x);
>          }
>       )
>    };
> 
> };
> 
> (* The follow#1 IN
> g code is from atoi.cl #1 IN
>  ~cs164/examples *)
> 
> (*
>    The #1 CLASS
>  A2I provides #1 IN
> teger-to-str#1 IN
> g and str#1 IN
> g-to-#1 IN
> teger
> conversion rout#1 IN
> es.  To use these rout#1 IN
> es, either #1 IN
> herit them
> IN
>  the #1 CLASS
>  where needed, have a dummy variable bound to
> someth#1 IN
> g #1 OF
>  type A2I, or simpl write (#1 NEW
>  A2I).method(argument).
> *)
> 
> (*
>    c2i   Converts a 1-character str#1 IN
> g to an #1 IN
> teger.  Aborts
>          #1 IF
>  the str#1 IN
> g is not "0" through "9"
> *)
497,955c239,477
< TYPEID A2I
< '{'
< OBJECTID c2i
< '('
< OBJECTID char
< ':'
< TYPEID String
< ')'
< ':'
< TYPEID Int
< '{'
< IF
< OBJECTID char
< '='
< STR_CONST "0"
< THEN
< INT_CONST 0
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "1"
< THEN
< INT_CONST 1
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "2"
< THEN
< INT_CONST 2
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "3"
< THEN
< INT_CONST 3
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "4"
< THEN
< INT_CONST 4
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "5"
< THEN
< INT_CONST 5
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "6"
< THEN
< INT_CONST 6
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "7"
< THEN
< INT_CONST 7
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "8"
< THEN
< INT_CONST 8
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "9"
< THEN
< INT_CONST 9
< ELSE
< '{'
< OBJECTID abort
< '('
< ')'
< ';'
< INT_CONST 0
< ';'
< '}'
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< '}'
< ';'
< OBJECTID i2c
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID String
< '{'
< IF
< OBJECTID i
< '='
< INT_CONST 0
< THEN
< STR_CONST "0"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 1
< THEN
< STR_CONST "1"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 2
< THEN
< STR_CONST "2"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 3
< THEN
< STR_CONST "3"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 4
< THEN
< STR_CONST "4"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 5
< THEN
< STR_CONST "5"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 6
< THEN
< STR_CONST "6"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 7
< THEN
< STR_CONST "7"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 8
< THEN
< STR_CONST "8"
< ELSE
< IF
< OBJECTID i
< '='
< INT_CONST 9
< THEN
< STR_CONST "9"
< ELSE
< '{'
< OBJECTID abort
< '('
< ')'
< ';'
< STR_CONST ""
< ';'
< '}'
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< '}'
< ';'
< OBJECTID a2i
< '('
< OBJECTID s
< ':'
< TYPEID String
< ')'
< ':'
< TYPEID Int
< '{'
< IF
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< '='
< INT_CONST 0
< THEN
< INT_CONST 0
< ELSE
< IF
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 0
< ','
< INT_CONST 1
< ')'
< '='
< STR_CONST "-"
< THEN
< '~'
< OBJECTID a2i_aux
< '('
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 1
< ','
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< '-'
< INT_CONST 1
< ')'
< ')'
< ELSE
< IF
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 0
< ','
< INT_CONST 1
< ')'
< '='
< STR_CONST "+"
< THEN
< OBJECTID a2i_aux
< '('
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< INT_CONST 1
< ','
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< '-'
< INT_CONST 1
< ')'
< ')'
< ELSE
< OBJECTID a2i_aux
< '('
< OBJECTID s
< ')'
< FI
< FI
< FI
< '}'
< ';'
< OBJECTID a2i_aux
< '('
< OBJECTID s
< ':'
< TYPEID String
< ')'
< ':'
< TYPEID Int
< '{'
< '('
< LET
< OBJECTID int
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 0
< IN
< '{'
< '('
< LET
< OBJECTID j
< ':'
< TYPEID Int
< ASSIGN
< OBJECTID s
< '.'
< OBJECTID length
< '('
< ')'
< IN
< '('
< LET
< OBJECTID i
< ':'
< TYPEID Int
< ASSIGN
< INT_CONST 0
< IN
< WHILE
< OBJECTID i
< '<'
< OBJECTID j
< LOOP
< '{'
< OBJECTID int
< ASSIGN
< OBJECTID int
< '*'
< INT_CONST 10
< '+'
< OBJECTID c2i
< '('
< OBJECTID s
< '.'
< OBJECTID substr
< '('
< OBJECTID i
< ','
< INT_CONST 1
< ')'
< ')'
< ';'
< OBJECTID i
< ASSIGN
< OBJECTID i
< '+'
< INT_CONST 1
< ';'
< '}'
< POOL
< ')'
< ')'
< ';'
< OBJECTID int
< ';'
< '}'
< ')'
< '}'
< ';'
< OBJECTID i2a
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID String
< '{'
< IF
< OBJECTID i
< '='
< INT_CONST 0
< THEN
< STR_CONST "0"
< ELSE
< IF
< INT_CONST 0
< '<'
< OBJECTID i
< THEN
< OBJECTID i2a_aux
< '('
< OBJECTID i
< ')'
< ELSE
< STR_CONST "-"
< '.'
< OBJECTID concat
< '('
< OBJECTID i2a_aux
< '('
< OBJECTID i
< '*'
< '~'
< INT_CONST 1
< ')'
< ')'
< FI
< FI
< '}'
< ';'
< OBJECTID i2a_aux
< '('
< OBJECTID i
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID String
< '{'
< IF
< OBJECTID i
< '='
< INT_CONST 0
< THEN
< STR_CONST ""
< ELSE
< '('
< LET
< OBJECTID next
< ':'
< TYPEID Int
< ASSIGN
< OBJECTID i
< '/'
< INT_CONST 10
< IN
< OBJECTID i2a_aux
< '('
< OBJECTID next
< ')'
< '.'
< OBJECTID concat
< '('
< OBJECTID i2c
< '('
< OBJECTID i
< '-'
< OBJECTID next
< '*'
< INT_CONST 10
< ')'
< ')'
< ')'
< FI
< '}'
< ';'
< '}'
< ';'
---
>  A2I {
> 
>      c2i(char : Str#1 IN
> g) : Int {
> 	#1 IF
>  char = "0" #1 THEN
>  0 #1 ELSE
> 
> 	#1 IF
>  char = "1" #1 THEN
>  1 #1 ELSE
> 
> 	#1 IF
>  char = "2" #1 THEN
>  2 #1 ELSE
> 
>         #1 IF
>  char = "3" #1 THEN
>  3 #1 ELSE
> 
>         #1 IF
>  char = "4" #1 THEN
>  4 #1 ELSE
> 
>         #1 IF
>  char = "5" #1 THEN
>  5 #1 ELSE
> 
>         #1 IF
>  char = "6" #1 THEN
>  6 #1 ELSE
> 
>         #1 IF
>  char = "7" #1 THEN
>  7 #1 ELSE
> 
>         #1 IF
>  char = "8" #1 THEN
>  8 #1 ELSE
> 
>         #1 IF
>  char = "9" #1 THEN
>  9 #1 ELSE
> 
>         { abort(); 0; }  (* the 0 is needed to satisfy the
> 				  typchecker *)
>         #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
> 
>      };
> 
> (*
>    i2c is the #1 IN
> verse #1 OF
>  c2i.
> *)
>      i2c(i : Int) : Str#1 IN
> g {
> 	#1 IF
>  i = 0 #1 THEN
>  "0" #1 ELSE
> 
> 	#1 IF
>  i = 1 #1 THEN
>  "1" #1 ELSE
> 
> 	#1 IF
>  i = 2 #1 THEN
>  "2" #1 ELSE
> 
> 	#1 IF
>  i = 3 #1 THEN
>  "3" #1 ELSE
> 
> 	#1 IF
>  i = 4 #1 THEN
>  "4" #1 ELSE
> 
> 	#1 IF
>  i = 5 #1 THEN
>  "5" #1 ELSE
> 
> 	#1 IF
>  i = 6 #1 THEN
>  "6" #1 ELSE
> 
> 	#1 IF
>  i = 7 #1 THEN
>  "7" #1 ELSE
> 
> 	#1 IF
>  i = 8 #1 THEN
>  "8" #1 ELSE
> 
> 	#1 IF
>  i = 9 #1 THEN
>  "9" #1 ELSE
> 
> 	{ abort(); ""; }  -- the "" is needed to satisfy the typchecker
>         #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
> 
>      };
> 
> (*
>    a2i converts an ASCII str#1 IN
> g #1 IN
> to an #1 IN
> teger.  The empty str#1 IN
> g
> is converted to 0.  Signed and unsigned str#1 IN
> gs are handled.  The
> method aborts #1 IF
>  the str#1 IN
> g does not represent an #1 IN
> teger.  Very
> long str#1 IN
> gs #1 OF
>  digits produce strange answers because #1 OF
>  arithmetic 
> overflow.
> 
> *)
>      a2i(s : Str#1 IN
> g) : Int {
>         #1 IF
>  s.length() = 0 #1 THEN
>  0 #1 ELSE
> 
> 	#1 IF
>  s.substr(0,1) = "-" #1 THEN
>  ~a2i_aux(s.substr(1,s.length()-1)) #1 ELSE
> 
>         #1 IF
>  s.substr(0,1) = "+" #1 THEN
>  a2i_aux(s.substr(1,s.length()-1)) #1 ELSE
> 
>            a2i_aux(s)
>         #1 FI
>  #1 FI
>  #1 FI
> 
>      };
> 
> (* a2i_aux converts the usigned portion #1 OF
>  the str#1 IN
> g.  As a
>    programm#1 IN
> g example, this method is written iteratively.  *)
> 
>      a2i_aux(s : Str#1 IN
> g) : Int {
> 	(#1 LET
>  #1 IN
> t : Int <- 0 #1 IN
> 	
>            {	
>                (#1 LET
>  j : Int <- s.length() #1 IN
> 
> 	          (#1 LET
>  i : Int <- 0 #1 IN
> 
> 		    #1 WHILE
>  i < j #1 LOOP
> 
> 			{
> 			    #1 IN
> t <- #1 IN
> t * 10 + c2i(s.substr(i,1));
> 			    i <- i + 1;
> 			}
> 		    #1 POOL
> 
> 		  )
> 	       );
>               #1 IN
> t;
> 	    }
>         )
>      };
> 
> (* i2a converts an #1 IN
> teger to a str#1 IN
> g.  Positive and negative 
>    numbers are handled correctly.  *)
> 
>     i2a(i : Int) : Str#1 IN
> g {
> 	#1 IF
>  i = 0 #1 THEN
>  "0" #1 ELSE
>  
>         #1 IF
>  0 < i #1 THEN
>  i2a_aux(i) #1 ELSE
> 
>           "-".concat(i2a_aux(i * ~1)) 
>         #1 FI
>  #1 FI
> 
>     };
> 	
> (* i2a_aux is an example us#1 IN
> g recursion.  *)		
> 
>     i2a_aux(i : Int) : Str#1 IN
> g {
>         #1 IF
>  i = 0 #1 THEN
>  "" #1 ELSE
>  
> 	    (#1 LET
>  next : Int <- i / 10 #1 IN
> 
> 		i2a_aux(next).concat(i2c(i - next * 10))
> 	    )
>         #1 FI
> 
>     };
> 
> };
> 
957,1858c479,856
< TYPEID Main
< INHERITS
< TYPEID IO
< '{'
< OBJECTID char
< ':'
< TYPEID String
< ';'
< OBJECTID avar
< ':'
< TYPEID A
< ';'
< OBJECTID a_var
< ':'
< TYPEID A
< ';'
< OBJECTID flag
< ':'
< TYPEID Bool
< ASSIGN
< BOOL_CONST true
< ';'
< OBJECTID menu
< '('
< ')'
< ':'
< TYPEID String
< '{'
< '{'
< OBJECTID out_string
< '('
< STR_CONST "\n\tTo add a number to "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "...enter a:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo negate "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "...enter b:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo find the difference between "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "and another number...enter c:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo find the factorial of "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "...enter d:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo square "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "...enter e:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo cube "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "...enter f:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo find out if "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "is a multiple of 3...enter g:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo divide "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "by 8...enter h:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo get a new number...enter j:\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\tTo quit...enter q:\n\n"
< ')'
< ';'
< OBJECTID in_string
< '('
< ')'
< ';'
< '}'
< '}'
< ';'
< OBJECTID prompt
< '('
< ')'
< ':'
< TYPEID String
< '{'
< '{'
< OBJECTID out_string
< '('
< STR_CONST "\n"
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "Please enter a number...  "
< ')'
< ';'
< OBJECTID in_string
< '('
< ')'
< ';'
< '}'
< '}'
< ';'
< OBJECTID get_int
< '('
< ')'
< ':'
< TYPEID Int
< '{'
< '{'
< '('
< LET
< OBJECTID z
< ':'
< TYPEID A2I
< ASSIGN
< NEW
< TYPEID A2I
< IN
< '('
< LET
< OBJECTID s
< ':'
< TYPEID String
< ASSIGN
< OBJECTID prompt
< '('
< ')'
< IN
< OBJECTID z
< '.'
< OBJECTID a2i
< '('
< OBJECTID s
< ')'
< ')'
< ')'
< ';'
< '}'
< '}'
< ';'
< OBJECTID is_even
< '('
< OBJECTID num
< ':'
< TYPEID Int
< ')'
< ':'
< TYPEID Bool
< '{'
< '('
< LET
< OBJECTID x
< ':'
< TYPEID Int
< ASSIGN
< OBJECTID num
< IN
< IF
< OBJECTID x
< '<'
< INT_CONST 0
< THEN
< OBJECTID is_even
< '('
< '~'
< OBJECTID x
< ')'
< ELSE
< IF
< INT_CONST 0
< '='
< OBJECTID x
< THEN
< BOOL_CONST true
< ELSE
< IF
< INT_CONST 1
< '='
< OBJECTID x
< THEN
< BOOL_CONST false
< ELSE
< OBJECTID is_even
< '('
< OBJECTID x
< '-'
< INT_CONST 2
< ')'
< FI
< FI
< FI
< ')'
< '}'
< ';'
< OBJECTID class_type
< '('
< OBJECTID var
< ':'
< TYPEID A
< ')'
< ':'
< TYPEID SELF_TYPE
< '{'
< CASE
< OBJECTID var
< OF
< OBJECTID a
< ':'
< TYPEID A
< DARROW
< OBJECTID out_string
< '('
< STR_CONST "Class type is now A\n"
< ')'
< ';'
< OBJECTID b
< ':'
< TYPEID B
< DARROW
< OBJECTID out_string
< '('
< STR_CONST "Class type is now B\n"
< ')'
< ';'
< OBJECTID c
< ':'
< TYPEID C
< DARROW
< OBJECTID out_string
< '('
< STR_CONST "Class type is now C\n"
< ')'
< ';'
< OBJECTID d
< ':'
< TYPEID D
< DARROW
< OBJECTID out_string
< '('
< STR_CONST "Class type is now D\n"
< ')'
< ';'
< OBJECTID e
< ':'
< TYPEID E
< DARROW
< OBJECTID out_string
< '('
< STR_CONST "Class type is now E\n"
< ')'
< ';'
< OBJECTID o
< ':'
< TYPEID Object
< DARROW
< OBJECTID out_string
< '('
< STR_CONST "Oooops\n"
< ')'
< ';'
< ESAC
< '}'
< ';'
< OBJECTID print
< '('
< OBJECTID var
< ':'
< TYPEID A
< ')'
< ':'
< TYPEID SELF_TYPE
< '{'
< '('
< LET
< OBJECTID z
< ':'
< TYPEID A2I
< ASSIGN
< NEW
< TYPEID A2I
< IN
< '{'
< OBJECTID out_string
< '('
< OBJECTID z
< '.'
< OBJECTID i2a
< '('
< OBJECTID var
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST " "
< ')'
< ';'
< '}'
< ')'
< '}'
< ';'
< OBJECTID main
< '('
< ')'
< ':'
< TYPEID Object
< '{'
< '{'
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID A
< ')'
< ';'
< WHILE
< OBJECTID flag
< LOOP
< '{'
< OBJECTID out_string
< '('
< STR_CONST "number "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< IF
< OBJECTID is_even
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< THEN
< OBJECTID out_string
< '('
< STR_CONST "is even!\n"
< ')'
< ELSE
< OBJECTID out_string
< '('
< STR_CONST "is odd!\n"
< ')'
< FI
< ';'
< OBJECTID class_type
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID char
< ASSIGN
< OBJECTID menu
< '('
< ')'
< ';'
< IF
< OBJECTID char
< '='
< STR_CONST "a"
< THEN
< '{'
< OBJECTID a_var
< ASSIGN
< '('
< NEW
< TYPEID A
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID get_int
< '('
< ')'
< ')'
< ';'
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID B
< ')'
< '.'
< OBJECTID method2
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ','
< OBJECTID a_var
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ';'
< '}'
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "b"
< THEN
< CASE
< OBJECTID avar
< OF
< OBJECTID c
< ':'
< TYPEID C
< DARROW
< OBJECTID avar
< ASSIGN
< OBJECTID c
< '.'
< OBJECTID method6
< '('
< OBJECTID c
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ';'
< OBJECTID a
< ':'
< TYPEID A
< DARROW
< OBJECTID avar
< ASSIGN
< OBJECTID a
< '.'
< OBJECTID method3
< '('
< OBJECTID a
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ';'
< OBJECTID o
< ':'
< TYPEID Object
< DARROW
< '{'
< OBJECTID out_string
< '('
< STR_CONST "Oooops\n"
< ')'
< ';'
< OBJECTID abort
< '('
< ')'
< ';'
< INT_CONST 0
< ';'
< '}'
< ';'
< ESAC
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "c"
< THEN
< '{'
< OBJECTID a_var
< ASSIGN
< '('
< NEW
< TYPEID A
< ')'
< '.'
< OBJECTID set_var
< '('
< OBJECTID get_int
< '('
< ')'
< ')'
< ';'
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID D
< ')'
< '.'
< OBJECTID method4
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ','
< OBJECTID a_var
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ';'
< '}'
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "d"
< THEN
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID C
< ')'
< '@'
< TYPEID A
< '.'
< OBJECTID method5
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "e"
< THEN
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID C
< ')'
< '@'
< TYPEID B
< '.'
< OBJECTID method5
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "f"
< THEN
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID C
< ')'
< '@'
< TYPEID C
< '.'
< OBJECTID method5
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "g"
< THEN
< IF
< '('
< '('
< NEW
< TYPEID D
< ')'
< '.'
< OBJECTID method7
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ')'
< THEN
< '{'
< OBJECTID out_string
< '('
< STR_CONST "number "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "is divisible by 3.\n"
< ')'
< ';'
< '}'
< ELSE
< '{'
< OBJECTID out_string
< '('
< STR_CONST "number "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "is not divisible by 3.\n"
< ')'
< ';'
< '}'
< FI
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "h"
< THEN
< '('
< LET
< OBJECTID x
< ':'
< TYPEID A
< IN
< '{'
< OBJECTID x
< ASSIGN
< '('
< NEW
< TYPEID E
< ')'
< '.'
< OBJECTID method6
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< ';'
< '('
< LET
< OBJECTID r
< ':'
< TYPEID Int
< ASSIGN
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< '-'
< '('
< OBJECTID x
< '.'
< OBJECTID value
< '('
< ')'
< '*'
< INT_CONST 8
< ')'
< ')'
< IN
< '{'
< OBJECTID out_string
< '('
< STR_CONST "number "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID avar
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "is equal to "
< ')'
< ';'
< OBJECTID print
< '('
< OBJECTID x
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "times 8 with a remainder of "
< ')'
< ';'
< '('
< LET
< OBJECTID a
< ':'
< TYPEID A2I
< ASSIGN
< NEW
< TYPEID A2I
< IN
< '{'
< OBJECTID out_string
< '('
< OBJECTID a
< '.'
< OBJECTID i2a
< '('
< OBJECTID r
< ')'
< ')'
< ';'
< OBJECTID out_string
< '('
< STR_CONST "\n"
< ')'
< ';'
< '}'
< ')'
< ';'
< '}'
< ')'
< ';'
< OBJECTID avar
< ASSIGN
< OBJECTID x
< ';'
< '}'
< ')'
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "j"
< THEN
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID A
< ')'
< ELSE
< IF
< OBJECTID char
< '='
< STR_CONST "q"
< THEN
< OBJECTID flag
< ASSIGN
< BOOL_CONST false
< ELSE
< OBJECTID avar
< ASSIGN
< '('
< NEW
< TYPEID A
< ')'
< '.'
< OBJECTID method1
< '('
< OBJECTID avar
< '.'
< OBJECTID value
< '('
< ')'
< ')'
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< FI
< ';'
< '}'
< POOL
< ';'
< '}'
< '}'
< ';'
< '}'
< ';'
---
>  Ma#1 IN
>  #1 INHERITS
>  IO {
>    
>    char : Str#1 IN
> g;
>    avar : A; 
>    a_var : A;
>    flag : Bool <- true;
> 
>    menu() : Str#1 IN
> g {
>       {
>          out_str#1 IN
> g("\n\tTo add a number to ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("...enter a:\n");
>          out_str#1 IN
> g("\tTo negate ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("...enter b:\n");
>          out_str#1 IN
> g("\tTo #1 FI
> nd the d#1 IF
> ference between ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("and another number...enter c:\n");
>          out_str#1 IN
> g("\tTo #1 FI
> nd the factorial #1 OF
>  ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("...enter d:\n");
>          out_str#1 IN
> g("\tTo square ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("...enter e:\n");
>          out_str#1 IN
> g("\tTo cube ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("...enter f:\n");
>          out_str#1 IN
> g("\tTo #1 FI
> nd out #1 IF
>  ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("is a multiple #1 OF
>  3...enter g:\n");
>          out_str#1 IN
> g("\tTo divide ");
>          pr#1 IN
> t(avar);
>          out_str#1 IN
> g("by 8...enter h:\n");
> 	 out_str#1 IN
> g("\tTo get a #1 NEW
>  number...enter j:\n");
> 	 out_str#1 IN
> g("\tTo quit...enter q:\n\n");
>          #1 IN
> _str#1 IN
> g();
>       }
>    };
> 
>    prompt() : Str#1 IN
> g {
>       {
>          out_str#1 IN
> g("\n");
>          out_str#1 IN
> g("Please enter a number...  ");
>          #1 IN
> _str#1 IN
> g();
>       }
>    };
> 
>    get_#1 IN
> t() : Int {
>       {
> 	 (#1 LET
>  z : A2I <- #1 NEW
>  A2I #1 IN
> 
> 	    (#1 LET
>  s : Str#1 IN
> g <- prompt() #1 IN
> 
> 	       z.a2i(s)
> 	    )
>          );
>       }
>    };
> 
>    is_even(num : Int) : Bool {
>       (#1 LET
>  x : Int <- num #1 IN
> 
>             #1 IF
>  x < 0 #1 THEN
>  is_even(~x) #1 ELSE
> 
>             #1 IF
>  0 = x #1 THEN
>  true #1 ELSE
> 
> 	    #1 IF
>  1 = x #1 THEN
>  false #1 ELSE
> 
> 	          is_even(x - 2)
> 	    #1 FI
>  #1 FI
>  #1 FI
> 
>       )
>    };
> 
>    #1 CLASS
> _type(var : A) : SELF_TYPE {
>       #1 CASE
>  var #1 OF
> 
> 	 a : A #1 DARROW
>  out_str#1 IN
> g("Class type is now A\n");
> 	 b : B #1 DARROW
>  out_str#1 IN
> g("Class type is now B\n");
> 	 c : C #1 DARROW
>  out_str#1 IN
> g("Class type is now C\n");
> 	 d : D #1 DARROW
>  out_str#1 IN
> g("Class type is now D\n");
> 	 e : E #1 DARROW
>  out_str#1 IN
> g("Class type is now E\n");
> 	 o : Object #1 DARROW
>  out_str#1 IN
> g("Oooops\n");
>       #1 ESAC
> 
>    };
>  
>    pr#1 IN
> t(var : A) : SELF_TYPE {
>      (#1 LET
>  z : A2I <- #1 NEW
>  A2I #1 IN
> 
> 	{
> 	   out_str#1 IN
> g(z.i2a(var.value()));
> 	   out_str#1 IN
> g(" ");
> 	}
>      )
>    };
> 
>    ma#1 IN
> () : Object {
>       {
>          avar <- (#1 NEW
>  A);
>          #1 WHILE
>  flag #1 LOOP
> 
>             {
> 	       -- avar <- (#1 NEW
>  A).set_var(get_#1 IN
> t());
> 	       out_str#1 IN
> g("number ");
> 	       pr#1 IN
> t(avar);
> 	       #1 IF
>  is_even(avar.value()) #1 THEN
> 
> 	          out_str#1 IN
> g("is even!\n")
> 	       #1 ELSE
> 
> 	          out_str#1 IN
> g("is odd!\n")
> 	       #1 FI
> ;
> 	       -- pr#1 IN
> t(avar); -- pr#1 IN
> ts out answer
> 	       #1 CLASS
> _type(avar);
> 	       char <- menu();
>                   #1 IF
>  char = "a" #1 THEN
>  -- add
>                      {
>                         a_var <- (#1 NEW
>  A).set_var(get_#1 IN
> t());
> 	                avar <- (#1 NEW
>  B).method2(avar.value(), a_var.value());
> 	             } #1 ELSE
> 
>                   #1 IF
>  char = "b" #1 THEN
>  -- negate
>                      #1 CASE
>  avar #1 OF
> 
> 	                   c : C #1 DARROW
>  avar <- c.method6(c.value());
> 	                   a : A #1 DARROW
>  avar <- a.method3(a.value());
> 	                   o : Object #1 DARROW
>  {
> 		                  out_str#1 IN
> g("Oooops\n");
> 		                  abort(); 0;
> 		               };
>                      #1 ESAC
>  #1 ELSE
> 
>                   #1 IF
>  char = "c" #1 THEN
>  -- d#1 IF
> f
>                      {
>                         a_var <- (#1 NEW
>  A).set_var(get_#1 IN
> t());
> 	                avar <- (#1 NEW
>  D).method4(avar.value(), a_var.value());
> 	             } #1 ELSE
> 
>                   #1 IF
>  char = "d" #1 THEN
>  avar <- (#1 NEW
>  C)@A.method5(avar.value()) #1 ELSE
> 
> 		          -- factorial
>                   #1 IF
>  char = "e" #1 THEN
>  avar <- (#1 NEW
>  C)@B.method5(avar.value()) #1 ELSE
> 
> 			  -- square
>                   #1 IF
>  char = "f" #1 THEN
>  avar <- (#1 NEW
>  C)@C.method5(avar.value()) #1 ELSE
> 
> 			  -- cube
>                   #1 IF
>  char = "g" #1 THEN
>  -- multiple #1 OF
>  3?
> 		      #1 IF
>  ((#1 NEW
>  D).method7(avar.value()))
> 		                       #1 THEN
>  -- avar <- (#1 NEW
>  A).method1(avar.value())
> 			 {
> 	                    out_str#1 IN
> g("number ");
> 	                    pr#1 IN
> t(avar);
> 	                    out_str#1 IN
> g("is divisible by 3.\n");
> 			 }
> 			 #1 ELSE
>   -- avar <- (#1 NEW
>  A).set_var(0)
> 			 {
> 	                    out_str#1 IN
> g("number ");
> 	                    pr#1 IN
> t(avar);
> 	                    out_str#1 IN
> g("is not divisible by 3.\n");
> 			 }
> 		      #1 FI
>  #1 ELSE
> 
>                   #1 IF
>  char = "h" #1 THEN
>  
> 		      (#1 LET
>  x : A #1 IN
> 
> 			 {
> 		            x <- (#1 NEW
>  E).method6(avar.value());
> 			    (#1 LET
>  r : Int <- (avar.value() - (x.value() * 8)) #1 IN
> 
> 			       {
> 			          out_str#1 IN
> g("number ");
> 			          pr#1 IN
> t(avar);
> 			          out_str#1 IN
> g("is equal to ");
> 			          pr#1 IN
> t(x);
> 			          out_str#1 IN
> g("times 8 with a rema#1 IN
> der #1 OF
>  ");
> 				  (#1 LET
>  a : A2I <- #1 NEW
>  A2I #1 IN
> 
> 				     {
> 			                out_str#1 IN
> g(a.i2a(r));
> 			                out_str#1 IN
> g("\n");
> 				     }
> 				  ); -- end #1 LET
>  a:
> 			       }
>                             ); -- end #1 LET
>  r:
> 			    avar <- x;
> 		         } 
> 		      )  -- end #1 LET
>  x:
> 		      #1 ELSE
> 
>                   #1 IF
>  char = "j" #1 THEN
>  avar <- (#1 NEW
>  A)
> 		      #1 ELSE
> 
>                   #1 IF
>  char = "q" #1 THEN
>  flag <- false
> 		      #1 ELSE
> 
>                       avar <- (#1 NEW
>  A).method1(avar.value()) -- divide/8
>                   #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
>  #1 FI
> ;
>             }
>          #1 POOL
> ;
>        }
>    };
> 
> };
> 
