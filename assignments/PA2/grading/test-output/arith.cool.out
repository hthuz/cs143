(*
 *  A contribution from Anne Sheets (sheets@cory)
 *
 *  Tests the arithmetic operations and various other th#1 IN
gs
 *)

CLASS
 A {

   var : Int <- 0;

   value() : Int { var };

   set_var(num : Int) : SELF_TYPE {
      {
         var <- num;
         self;
      }
   };

   method1(num : Int) : SELF_TYPE {  -- same
      self
   };

   method2(num1 : Int, num2 : Int) : B {  -- plus
      (#1 LET
 x : Int #1 IN

	 {
            x <- num1 + num2;
	    (#1 NEW
 B).set_var(x);
	 }
      )
   };

   method3(num : Int) : C {  -- negate
      (#1 LET
 x : Int #1 IN

	 {
            x <- ~num;
	    (#1 NEW
 C).set_var(x);
	 }
      )
   };

   method4(num1 : Int, num2 : Int) : D {  -- d#1 IF
f
            #1 IF
 num2 < num1 #1 THEN

               (#1 LET
 x : Int #1 IN

		  {
                     x <- num1 - num2;
	             (#1 NEW
 D).set_var(x);
	          }
               )
            #1 ELSE

               (#1 LET
 x : Int #1 IN

		  {
	             x <- num2 - num1;
	             (#1 NEW
 D).set_var(x);
		  }
               )
            #1 FI

   };

   method5(num : Int) : E {  -- factorial
      (#1 LET
 x : Int <- 1 #1 IN

	 {
	    (#1 LET
 y : Int <- 1 #1 IN

	       #1 WHILE
 y <= num #1 LOOP

	          {
                     x <- x * y;
	             y <- y + 1;
	          }
	       #1 POOL

	    );
	    (#1 NEW
 E).set_var(x);
	 }
      )
   };

};

CLASS
 B #1 INHERITS
 A {  -- B is a number squared

   method5(num : Int) : E { -- square
      (#1 LET
 x : Int #1 IN

	 {
            x <- num * num;
	    (#1 NEW
 E).set_var(x);
	 }
      )
   };

};

CLASS
 C #1 INHERITS
 B {

   method6(num : Int) : A { -- negate
      (#1 LET
 x : Int #1 IN

         {
            x <- ~num;
	    (#1 NEW
 A).set_var(x);
         }
      )
   };

   method5(num : Int) : E {  -- cube
      (#1 LET
 x : Int #1 IN

	 {
            x <- num * num * num;
	    (#1 NEW
 E).set_var(x);
	 }
      )
   };

};

CLASS
 D #1 INHERITS
 B {  
		
   method7(num : Int) : Bool {  -- divisible by 3
      (#1 LET
 x : Int <- num #1 IN

            #1 IF
 x < 0 #1 THEN
 method7(~x) #1 ELSE

            #1 IF
 0 = x #1 THEN
 true #1 ELSE

            #1 IF
 1 = x #1 THEN
 false #1 ELSE

	    #1 IF
 2 = x #1 THEN
 false #1 ELSE

	       method7(x - 3)
	    #1 FI
 #1 FI
 #1 FI
 #1 FI

      )
   };

};

CLASS
 E #1 INHERITS
 D {

   method6(num : Int) : A {  -- division
      (#1 LET
 x : Int #1 IN

         {
            x <- num / 8;
	    (#1 NEW
 A).set_var(x);
         }
      )
   };

};

(* The follow#1 IN
g code is from atoi.cl #1 IN
 ~cs164/examples *)

(*
   The #1 CLASS
 A2I provides #1 IN
teger-to-str#1 IN
g and str#1 IN
g-to-#1 IN
teger
conversion rout#1 IN
es.  To use these rout#1 IN
es, either #1 IN
herit them
IN
 the #1 CLASS
 where needed, have a dummy variable bound to
someth#1 IN
g #1 OF
 type A2I, or simpl write (#1 NEW
 A2I).method(argument).
*)

(*
   c2i   Converts a 1-character str#1 IN
g to an #1 IN
teger.  Aborts
         #1 IF
 the str#1 IN
g is not "0" through "9"
*)
CLASS
 A2I {

     c2i(char : Str#1 IN
g) : Int {
	#1 IF
 char = "0" #1 THEN
 0 #1 ELSE

	#1 IF
 char = "1" #1 THEN
 1 #1 ELSE

	#1 IF
 char = "2" #1 THEN
 2 #1 ELSE

        #1 IF
 char = "3" #1 THEN
 3 #1 ELSE

        #1 IF
 char = "4" #1 THEN
 4 #1 ELSE

        #1 IF
 char = "5" #1 THEN
 5 #1 ELSE

        #1 IF
 char = "6" #1 THEN
 6 #1 ELSE

        #1 IF
 char = "7" #1 THEN
 7 #1 ELSE

        #1 IF
 char = "8" #1 THEN
 8 #1 ELSE

        #1 IF
 char = "9" #1 THEN
 9 #1 ELSE

        { abort(); 0; }  (* the 0 is needed to satisfy the
				  typchecker *)
        #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI

     };

(*
   i2c is the #1 IN
verse #1 OF
 c2i.
*)
     i2c(i : Int) : Str#1 IN
g {
	#1 IF
 i = 0 #1 THEN
 "0" #1 ELSE

	#1 IF
 i = 1 #1 THEN
 "1" #1 ELSE

	#1 IF
 i = 2 #1 THEN
 "2" #1 ELSE

	#1 IF
 i = 3 #1 THEN
 "3" #1 ELSE

	#1 IF
 i = 4 #1 THEN
 "4" #1 ELSE

	#1 IF
 i = 5 #1 THEN
 "5" #1 ELSE

	#1 IF
 i = 6 #1 THEN
 "6" #1 ELSE

	#1 IF
 i = 7 #1 THEN
 "7" #1 ELSE

	#1 IF
 i = 8 #1 THEN
 "8" #1 ELSE

	#1 IF
 i = 9 #1 THEN
 "9" #1 ELSE

	{ abort(); ""; }  -- the "" is needed to satisfy the typchecker
        #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI

     };

(*
   a2i converts an ASCII str#1 IN
g #1 IN
to an #1 IN
teger.  The empty str#1 IN
g
is converted to 0.  Signed and unsigned str#1 IN
gs are handled.  The
method aborts #1 IF
 the str#1 IN
g does not represent an #1 IN
teger.  Very
long str#1 IN
gs #1 OF
 digits produce strange answers because #1 OF
 arithmetic 
overflow.

*)
     a2i(s : Str#1 IN
g) : Int {
        #1 IF
 s.length() = 0 #1 THEN
 0 #1 ELSE

	#1 IF
 s.substr(0,1) = "-" #1 THEN
 ~a2i_aux(s.substr(1,s.length()-1)) #1 ELSE

        #1 IF
 s.substr(0,1) = "+" #1 THEN
 a2i_aux(s.substr(1,s.length()-1)) #1 ELSE

           a2i_aux(s)
        #1 FI
 #1 FI
 #1 FI

     };

(* a2i_aux converts the usigned portion #1 OF
 the str#1 IN
g.  As a
   programm#1 IN
g example, this method is written iteratively.  *)

     a2i_aux(s : Str#1 IN
g) : Int {
	(#1 LET
 #1 IN
t : Int <- 0 #1 IN
	
           {	
               (#1 LET
 j : Int <- s.length() #1 IN

	          (#1 LET
 i : Int <- 0 #1 IN

		    #1 WHILE
 i < j #1 LOOP

			{
			    #1 IN
t <- #1 IN
t * 10 + c2i(s.substr(i,1));
			    i <- i + 1;
			}
		    #1 POOL

		  )
	       );
              #1 IN
t;
	    }
        )
     };

(* i2a converts an #1 IN
teger to a str#1 IN
g.  Positive and negative 
   numbers are handled correctly.  *)

    i2a(i : Int) : Str#1 IN
g {
	#1 IF
 i = 0 #1 THEN
 "0" #1 ELSE
 
        #1 IF
 0 < i #1 THEN
 i2a_aux(i) #1 ELSE

          "-".concat(i2a_aux(i * ~1)) 
        #1 FI
 #1 FI

    };
	
(* i2a_aux is an example us#1 IN
g recursion.  *)		

    i2a_aux(i : Int) : Str#1 IN
g {
        #1 IF
 i = 0 #1 THEN
 "" #1 ELSE
 
	    (#1 LET
 next : Int <- i / 10 #1 IN

		i2a_aux(next).concat(i2c(i - next * 10))
	    )
        #1 FI

    };

};

CLASS
 Ma#1 IN
 #1 INHERITS
 IO {
   
   char : Str#1 IN
g;
   avar : A; 
   a_var : A;
   flag : Bool <- true;

   menu() : Str#1 IN
g {
      {
         out_str#1 IN
g("\n\tTo add a number to ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("...enter a:\n");
         out_str#1 IN
g("\tTo negate ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("...enter b:\n");
         out_str#1 IN
g("\tTo #1 FI
nd the d#1 IF
ference between ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("and another number...enter c:\n");
         out_str#1 IN
g("\tTo #1 FI
nd the factorial #1 OF
 ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("...enter d:\n");
         out_str#1 IN
g("\tTo square ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("...enter e:\n");
         out_str#1 IN
g("\tTo cube ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("...enter f:\n");
         out_str#1 IN
g("\tTo #1 FI
nd out #1 IF
 ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("is a multiple #1 OF
 3...enter g:\n");
         out_str#1 IN
g("\tTo divide ");
         pr#1 IN
t(avar);
         out_str#1 IN
g("by 8...enter h:\n");
	 out_str#1 IN
g("\tTo get a #1 NEW
 number...enter j:\n");
	 out_str#1 IN
g("\tTo quit...enter q:\n\n");
         #1 IN
_str#1 IN
g();
      }
   };

   prompt() : Str#1 IN
g {
      {
         out_str#1 IN
g("\n");
         out_str#1 IN
g("Please enter a number...  ");
         #1 IN
_str#1 IN
g();
      }
   };

   get_#1 IN
t() : Int {
      {
	 (#1 LET
 z : A2I <- #1 NEW
 A2I #1 IN

	    (#1 LET
 s : Str#1 IN
g <- prompt() #1 IN

	       z.a2i(s)
	    )
         );
      }
   };

   is_even(num : Int) : Bool {
      (#1 LET
 x : Int <- num #1 IN

            #1 IF
 x < 0 #1 THEN
 is_even(~x) #1 ELSE

            #1 IF
 0 = x #1 THEN
 true #1 ELSE

	    #1 IF
 1 = x #1 THEN
 false #1 ELSE

	          is_even(x - 2)
	    #1 FI
 #1 FI
 #1 FI

      )
   };

   #1 CLASS
_type(var : A) : SELF_TYPE {
      #1 CASE
 var #1 OF

	 a : A #1 DARROW
 out_str#1 IN
g("Class type is now A\n");
	 b : B #1 DARROW
 out_str#1 IN
g("Class type is now B\n");
	 c : C #1 DARROW
 out_str#1 IN
g("Class type is now C\n");
	 d : D #1 DARROW
 out_str#1 IN
g("Class type is now D\n");
	 e : E #1 DARROW
 out_str#1 IN
g("Class type is now E\n");
	 o : Object #1 DARROW
 out_str#1 IN
g("Oooops\n");
      #1 ESAC

   };
 
   pr#1 IN
t(var : A) : SELF_TYPE {
     (#1 LET
 z : A2I <- #1 NEW
 A2I #1 IN

	{
	   out_str#1 IN
g(z.i2a(var.value()));
	   out_str#1 IN
g(" ");
	}
     )
   };

   ma#1 IN
() : Object {
      {
         avar <- (#1 NEW
 A);
         #1 WHILE
 flag #1 LOOP

            {
	       -- avar <- (#1 NEW
 A).set_var(get_#1 IN
t());
	       out_str#1 IN
g("number ");
	       pr#1 IN
t(avar);
	       #1 IF
 is_even(avar.value()) #1 THEN

	          out_str#1 IN
g("is even!\n")
	       #1 ELSE

	          out_str#1 IN
g("is odd!\n")
	       #1 FI
;
	       -- pr#1 IN
t(avar); -- pr#1 IN
ts out answer
	       #1 CLASS
_type(avar);
	       char <- menu();
                  #1 IF
 char = "a" #1 THEN
 -- add
                     {
                        a_var <- (#1 NEW
 A).set_var(get_#1 IN
t());
	                avar <- (#1 NEW
 B).method2(avar.value(), a_var.value());
	             } #1 ELSE

                  #1 IF
 char = "b" #1 THEN
 -- negate
                     #1 CASE
 avar #1 OF

	                   c : C #1 DARROW
 avar <- c.method6(c.value());
	                   a : A #1 DARROW
 avar <- a.method3(a.value());
	                   o : Object #1 DARROW
 {
		                  out_str#1 IN
g("Oooops\n");
		                  abort(); 0;
		               };
                     #1 ESAC
 #1 ELSE

                  #1 IF
 char = "c" #1 THEN
 -- d#1 IF
f
                     {
                        a_var <- (#1 NEW
 A).set_var(get_#1 IN
t());
	                avar <- (#1 NEW
 D).method4(avar.value(), a_var.value());
	             } #1 ELSE

                  #1 IF
 char = "d" #1 THEN
 avar <- (#1 NEW
 C)@A.method5(avar.value()) #1 ELSE

		          -- factorial
                  #1 IF
 char = "e" #1 THEN
 avar <- (#1 NEW
 C)@B.method5(avar.value()) #1 ELSE

			  -- square
                  #1 IF
 char = "f" #1 THEN
 avar <- (#1 NEW
 C)@C.method5(avar.value()) #1 ELSE

			  -- cube
                  #1 IF
 char = "g" #1 THEN
 -- multiple #1 OF
 3?
		      #1 IF
 ((#1 NEW
 D).method7(avar.value()))
		                       #1 THEN
 -- avar <- (#1 NEW
 A).method1(avar.value())
			 {
	                    out_str#1 IN
g("number ");
	                    pr#1 IN
t(avar);
	                    out_str#1 IN
g("is divisible by 3.\n");
			 }
			 #1 ELSE
  -- avar <- (#1 NEW
 A).set_var(0)
			 {
	                    out_str#1 IN
g("number ");
	                    pr#1 IN
t(avar);
	                    out_str#1 IN
g("is not divisible by 3.\n");
			 }
		      #1 FI
 #1 ELSE

                  #1 IF
 char = "h" #1 THEN
 
		      (#1 LET
 x : A #1 IN

			 {
		            x <- (#1 NEW
 E).method6(avar.value());
			    (#1 LET
 r : Int <- (avar.value() - (x.value() * 8)) #1 IN

			       {
			          out_str#1 IN
g("number ");
			          pr#1 IN
t(avar);
			          out_str#1 IN
g("is equal to ");
			          pr#1 IN
t(x);
			          out_str#1 IN
g("times 8 with a rema#1 IN
der #1 OF
 ");
				  (#1 LET
 a : A2I <- #1 NEW
 A2I #1 IN

				     {
			                out_str#1 IN
g(a.i2a(r));
			                out_str#1 IN
g("\n");
				     }
				  ); -- end #1 LET
 a:
			       }
                            ); -- end #1 LET
 r:
			    avar <- x;
		         } 
		      )  -- end #1 LET
 x:
		      #1 ELSE

                  #1 IF
 char = "j" #1 THEN
 avar <- (#1 NEW
 A)
		      #1 ELSE

                  #1 IF
 char = "q" #1 THEN
 flag <- false
		      #1 ELSE

                      avar <- (#1 NEW
 A).method1(avar.value()) -- divide/8
                  #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
 #1 FI
;
            }
         #1 POOL
;
       }
   };

};

